/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package test.collections

//
// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLibTests.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//

import kotlin.test.*

class _UArraysTest {
    @Test
    fun foldIndexed_UIntArray() {
        expect(8u) { uintArrayOf(1u, 2u, 3u).foldIndexed(0u) { i, acc, e -> acc + i.toUInt() * e } }
        expect(10) { uintArrayOf(1u, 2u, 3u).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15u) { uintArrayOf(1u, 2u, 3u).foldIndexed(1u) { i, acc, e -> acc * (i.toUInt() + e) } }
        expect(" 0-${1u} 1-${2u} 2-${3u}") { uintArrayOf(1u, 2u, 3u).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42u) {
            val numbers = uintArrayOf(1u, 2u, 3u, 4u)
            numbers.foldIndexed(0u) { index, a, b -> index.toUInt() * (a + b) }
        }
        expect(0u) {
            val numbers = uintArrayOf()
            numbers.foldIndexed(0u) { index, a, b -> index.toUInt() * (a + b) }
        }
        expect("${1u}${1u}${2u}${3u}${4u}") {
            val numbers = uintArrayOf(1u, 2u, 3u, 4u)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldIndexed_ULongArray() {
        expect(8uL) { ulongArrayOf(1uL, 2uL, 3uL).foldIndexed(0uL) { i, acc, e -> acc + i.toULong() * e } }
        expect(10) { ulongArrayOf(1uL, 2uL, 3uL).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15uL) { ulongArrayOf(1uL, 2uL, 3uL).foldIndexed(1uL) { i, acc, e -> acc * (i.toULong() + e) } }
        expect(" 0-${1uL} 1-${2uL} 2-${3uL}") { ulongArrayOf(1uL, 2uL, 3uL).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42uL) {
            val numbers = ulongArrayOf(1uL, 2uL, 3uL, 4uL)
            numbers.foldIndexed(0uL) { index, a, b -> index.toULong() * (a + b) }
        }
        expect(0uL) {
            val numbers = ulongArrayOf()
            numbers.foldIndexed(0uL) { index, a, b -> index.toULong() * (a + b) }
        }
        expect("${1uL}${1uL}${2uL}${3uL}${4uL}") {
            val numbers = ulongArrayOf(1uL, 2uL, 3uL, 4uL)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldIndexed_UByteArray() {
        expect(8u) { ubyteArrayOf(1u, 2u, 3u).foldIndexed(0u) { i, acc, e -> acc + i.toUByte() * e } }
        expect(10) { ubyteArrayOf(1u, 2u, 3u).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15u) { ubyteArrayOf(1u, 2u, 3u).foldIndexed(1u) { i, acc, e -> acc * (i.toUByte() + e) } }
        expect(" 0-${1u} 1-${2u} 2-${3u}") { ubyteArrayOf(1u, 2u, 3u).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42u) {
            val numbers = ubyteArrayOf(1u, 2u, 3u, 4u)
            numbers.foldIndexed(0u) { index, a, b -> index.toUByte() * (a + b) }
        }
        expect(0u) {
            val numbers = ubyteArrayOf()
            numbers.foldIndexed(0u) { index, a, b -> index.toUByte() * (a + b) }
        }
        expect("${1u}${1u}${2u}${3u}${4u}") {
            val numbers = ubyteArrayOf(1u, 2u, 3u, 4u)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldIndexed_UShortArray() {
        expect(8u) { ushortArrayOf(1u, 2u, 3u).foldIndexed(0u) { i, acc, e -> acc + i.toUShort() * e } }
        expect(10) { ushortArrayOf(1u, 2u, 3u).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15u) { ushortArrayOf(1u, 2u, 3u).foldIndexed(1u) { i, acc, e -> acc * (i.toUShort() + e) } }
        expect(" 0-${1u} 1-${2u} 2-${3u}") { ushortArrayOf(1u, 2u, 3u).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42u) {
            val numbers = ushortArrayOf(1u, 2u, 3u, 4u)
            numbers.foldIndexed(0u) { index, a, b -> index.toUShort() * (a + b) }
        }
        expect(0u) {
            val numbers = ushortArrayOf()
            numbers.foldIndexed(0u) { index, a, b -> index.toUShort() * (a + b) }
        }
        expect("${1u}${1u}${2u}${3u}${4u}") {
            val numbers = ushortArrayOf(1u, 2u, 3u, 4u)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldRightIndexed_UIntArray() {
        expect(8u) { uintArrayOf(1u, 2u, 3u).foldRightIndexed(0u) { i, e, acc -> acc + i.toUInt() * e } }
        expect(10) { uintArrayOf(1u, 2u, 3u).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15u) { uintArrayOf(1u, 2u, 3u).foldRightIndexed(1u) { i, e, acc -> acc * (i.toUInt() + e) } }
        expect(" 2-${3u} 1-${2u} 0-${1u}") { uintArrayOf(1u, 2u, 3u).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1u}${2u}${3u}${4u}3210") {
            val numbers = uintArrayOf(1u, 2u, 3u, 4u)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun foldRightIndexed_ULongArray() {
        expect(8uL) { ulongArrayOf(1uL, 2uL, 3uL).foldRightIndexed(0uL) { i, e, acc -> acc + i.toULong() * e } }
        expect(10) { ulongArrayOf(1uL, 2uL, 3uL).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15uL) { ulongArrayOf(1uL, 2uL, 3uL).foldRightIndexed(1uL) { i, e, acc -> acc * (i.toULong() + e) } }
        expect(" 2-${3uL} 1-${2uL} 0-${1uL}") { ulongArrayOf(1uL, 2uL, 3uL).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1uL}${2uL}${3uL}${4uL}3210") {
            val numbers = ulongArrayOf(1uL, 2uL, 3uL, 4uL)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun foldRightIndexed_UByteArray() {
        expect(8u) { ubyteArrayOf(1u, 2u, 3u).foldRightIndexed(0u) { i, e, acc -> acc + i.toUByte() * e } }
        expect(10) { ubyteArrayOf(1u, 2u, 3u).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15u) { ubyteArrayOf(1u, 2u, 3u).foldRightIndexed(1u) { i, e, acc -> acc * (i.toUByte() + e) } }
        expect(" 2-${3u} 1-${2u} 0-${1u}") { ubyteArrayOf(1u, 2u, 3u).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1u}${2u}${3u}${4u}3210") {
            val numbers = ubyteArrayOf(1u, 2u, 3u, 4u)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun foldRightIndexed_UShortArray() {
        expect(8u) { ushortArrayOf(1u, 2u, 3u).foldRightIndexed(0u) { i, e, acc -> acc + i.toUShort() * e } }
        expect(10) { ushortArrayOf(1u, 2u, 3u).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15u) { ushortArrayOf(1u, 2u, 3u).foldRightIndexed(1u) { i, e, acc -> acc * (i.toUShort() + e) } }
        expect(" 2-${3u} 1-${2u} 0-${1u}") { ushortArrayOf(1u, 2u, 3u).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1u}${2u}${3u}${4u}3210") {
            val numbers = ushortArrayOf(1u, 2u, 3u, 4u)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun minBy_UIntArray() {
        assertEquals(null, uintArrayOf().minBy { it })
        assertEquals(1u, uintArrayOf(1u).minBy { it })
        assertEquals(2u, uintArrayOf(3u, 2u).minBy { it * it })
        assertEquals(3u, uintArrayOf(3u, 2u).minBy { "a" })
        assertEquals(2u, uintArrayOf(3u, 2u).minBy { it.toString() })
    }

    @Test
    fun minBy_ULongArray() {
        assertEquals(null, ulongArrayOf().minBy { it })
        assertEquals(1uL, ulongArrayOf(1uL).minBy { it })
        assertEquals(2uL, ulongArrayOf(3uL, 2uL).minBy { it * it })
        assertEquals(3uL, ulongArrayOf(3uL, 2uL).minBy { "a" })
        assertEquals(2uL, ulongArrayOf(3uL, 2uL).minBy { it.toString() })
    }

    @Test
    fun minBy_UByteArray() {
        assertEquals(null, ubyteArrayOf().minBy { it })
        assertEquals(1u, ubyteArrayOf(1u).minBy { it })
        assertEquals(2u, ubyteArrayOf(3u, 2u).minBy { it * it })
        assertEquals(3u, ubyteArrayOf(3u, 2u).minBy { "a" })
        assertEquals(2u, ubyteArrayOf(3u, 2u).minBy { it.toString() })
    }

    @Test
    fun minBy_UShortArray() {
        assertEquals(null, ushortArrayOf().minBy { it })
        assertEquals(1u, ushortArrayOf(1u).minBy { it })
        assertEquals(2u, ushortArrayOf(3u, 2u).minBy { it * it })
        assertEquals(3u, ushortArrayOf(3u, 2u).minBy { "a" })
        assertEquals(2u, ushortArrayOf(3u, 2u).minBy { it.toString() })
    }

    @Test
    fun minWith_UIntArray() {
        assertEquals(null, uintArrayOf().minWith(naturalOrder()))
        assertEquals(1u, uintArrayOf(1u).minWith(naturalOrder()))
        assertEquals(4u, uintArrayOf(2u, 3u, 4u).minWith(compareBy { it % 4u }))
    }

    @Test
    fun minWith_ULongArray() {
        assertEquals(null, ulongArrayOf().minWith(naturalOrder()))
        assertEquals(1uL, ulongArrayOf(1uL).minWith(naturalOrder()))
        assertEquals(4uL, ulongArrayOf(2uL, 3uL, 4uL).minWith(compareBy { it % 4uL }))
    }

    @Test
    fun minWith_UByteArray() {
        assertEquals(null, ubyteArrayOf().minWith(naturalOrder()))
        assertEquals(1u, ubyteArrayOf(1u).minWith(naturalOrder()))
        assertEquals(4u, ubyteArrayOf(2u, 3u, 4u).minWith(compareBy { it % 4u }))
    }

    @Test
    fun minWith_UShortArray() {
        assertEquals(null, ushortArrayOf().minWith(naturalOrder()))
        assertEquals(1u, ushortArrayOf(1u).minWith(naturalOrder()))
        assertEquals(4u, ushortArrayOf(2u, 3u, 4u).minWith(compareBy { it % 4u }))
    }

    @Test
    fun indexOf_UIntArray() {
        expect(-1) { uintArrayOf(1u, 2u, 3u).indexOf(0u) }
        expect(0) { uintArrayOf(1u, 2u, 3u).indexOf(1u) }
        expect(1) { uintArrayOf(1u, 2u, 3u).indexOf(2u) }
        expect(2) { uintArrayOf(1u, 2u, 3u).indexOf(3u) } 
    }

    @Test
    fun indexOf_ULongArray() {
        expect(-1) { ulongArrayOf(1uL, 2uL, 3uL).indexOf(0uL) }
        expect(0) { ulongArrayOf(1uL, 2uL, 3uL).indexOf(1uL) }
        expect(1) { ulongArrayOf(1uL, 2uL, 3uL).indexOf(2uL) }
        expect(2) { ulongArrayOf(1uL, 2uL, 3uL).indexOf(3uL) } 
    }

    @Test
    fun indexOf_UByteArray() {
        expect(-1) { ubyteArrayOf(1u, 2u, 3u).indexOf(0u) }
        expect(0) { ubyteArrayOf(1u, 2u, 3u).indexOf(1u) }
        expect(1) { ubyteArrayOf(1u, 2u, 3u).indexOf(2u) }
        expect(2) { ubyteArrayOf(1u, 2u, 3u).indexOf(3u) } 
    }

    @Test
    fun indexOf_UShortArray() {
        expect(-1) { ushortArrayOf(1u, 2u, 3u).indexOf(0u) }
        expect(0) { ushortArrayOf(1u, 2u, 3u).indexOf(1u) }
        expect(1) { ushortArrayOf(1u, 2u, 3u).indexOf(2u) }
        expect(2) { ushortArrayOf(1u, 2u, 3u).indexOf(3u) } 
    }

    @Test
    fun indexOfFirst_UIntArray() {
        expect(-1) { uintArrayOf(1u, 2u, 3u).indexOfFirst { it == 0u } }
        expect(0) { uintArrayOf(1u, 2u, 3u).indexOfFirst { it % 2u == 1u } }
        expect(1) { uintArrayOf(1u, 2u, 3u).indexOfFirst { it % 2u == 0u } }
        expect(2) { uintArrayOf(1u, 2u, 3u).indexOfFirst { it == 3u } }
    }

    @Test
    fun indexOfFirst_ULongArray() {
        expect(-1) { ulongArrayOf(1uL, 2uL, 3uL).indexOfFirst { it == 0uL } }
        expect(0) { ulongArrayOf(1uL, 2uL, 3uL).indexOfFirst { it % 2uL == 1uL } }
        expect(1) { ulongArrayOf(1uL, 2uL, 3uL).indexOfFirst { it % 2uL == 0uL } }
        expect(2) { ulongArrayOf(1uL, 2uL, 3uL).indexOfFirst { it == 3uL } }
    }

    @Test
    fun indexOfFirst_UByteArray() {
        expect(-1) { ubyteArrayOf(1u, 2u, 3u).indexOfFirst { it == 0.toUByte() } }
        expect(0) { ubyteArrayOf(1u, 2u, 3u).indexOfFirst { it % 2u == 1u } }
        expect(1) { ubyteArrayOf(1u, 2u, 3u).indexOfFirst { it % 2u == 0u } }
        expect(2) { ubyteArrayOf(1u, 2u, 3u).indexOfFirst { it == 3.toUByte() } }
    }

    @Test
    fun indexOfFirst_UShortArray() {
        expect(-1) { ushortArrayOf(1u, 2u, 3u).indexOfFirst { it == 0.toUShort() } }
        expect(0) { ushortArrayOf(1u, 2u, 3u).indexOfFirst { it % 2u == 1u } }
        expect(1) { ushortArrayOf(1u, 2u, 3u).indexOfFirst { it % 2u == 0u } }
        expect(2) { ushortArrayOf(1u, 2u, 3u).indexOfFirst { it == 3.toUShort() } }
    }

    @Test
    fun copyInto_UIntArray() {
        val dest = uintArrayOf(1u, 2u, 3u)
        val newValues = uintArrayOf(4u, 5u, 6u)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = uintArrayOf(5u, 6u, 3u)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = uintArrayOf(6u, 3u, 3u)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = uintArrayOf(6u, 6u, 3u)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

    @Test
    fun copyInto_ULongArray() {
        val dest = ulongArrayOf(1uL, 2uL, 3uL)
        val newValues = ulongArrayOf(4uL, 5uL, 6uL)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = ulongArrayOf(5uL, 6uL, 3uL)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = ulongArrayOf(6uL, 3uL, 3uL)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = ulongArrayOf(6uL, 6uL, 3uL)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

    @Test
    fun copyInto_UByteArray() {
        val dest = ubyteArrayOf(1u, 2u, 3u)
        val newValues = ubyteArrayOf(4u, 5u, 6u)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = ubyteArrayOf(5u, 6u, 3u)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = ubyteArrayOf(6u, 3u, 3u)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = ubyteArrayOf(6u, 6u, 3u)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

    @Test
    fun copyInto_UShortArray() {
        val dest = ushortArrayOf(1u, 2u, 3u)
        val newValues = ushortArrayOf(4u, 5u, 6u)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = ushortArrayOf(5u, 6u, 3u)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = ushortArrayOf(6u, 3u, 3u)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = ushortArrayOf(6u, 6u, 3u)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

}
