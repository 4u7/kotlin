/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package test.collections

//
// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLibTests.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//

import test.comparisons.STRING_CASE_INSENSITIVE_ORDER
import kotlin.test.*

class _ArraysTest {
    @Test
    fun foldIndexed_Array() {
        expect(8) { arrayOf<Int>(1, 2, 3).foldIndexed(0) { i, acc, e -> acc + i.toInt() * e } }
        expect(10) { arrayOf<Int>(1, 2, 3).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15) { arrayOf<Int>(1, 2, 3).foldIndexed(1) { i, acc, e -> acc * (i.toInt() + e) } }
        expect(" 0-${1} 1-${2} 2-${3}") { arrayOf<Int>(1, 2, 3).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42) {
            val numbers = arrayOf<Int>(1, 2, 3, 4)
            numbers.foldIndexed(0) { index, a, b -> index.toInt() * (a + b) }
        }
        expect(0) {
            val numbers = arrayOf<Int>()
            numbers.foldIndexed(0) { index, a, b -> index.toInt() * (a + b) }
        }
        expect("${1}${1}${2}${3}${4}") {
            val numbers = arrayOf<Int>(1, 2, 3, 4)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldIndexed_ByteArray() {
        expect(8) { byteArrayOf(1, 2, 3).foldIndexed(0) { i, acc, e -> acc + i.toByte() * e } }
        expect(10) { byteArrayOf(1, 2, 3).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15) { byteArrayOf(1, 2, 3).foldIndexed(1) { i, acc, e -> acc * (i.toByte() + e) } }
        expect(" 0-${1} 1-${2} 2-${3}") { byteArrayOf(1, 2, 3).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42) {
            val numbers = byteArrayOf(1, 2, 3, 4)
            numbers.foldIndexed(0) { index, a, b -> index.toByte() * (a + b) }
        }
        expect(0) {
            val numbers = byteArrayOf()
            numbers.foldIndexed(0) { index, a, b -> index.toByte() * (a + b) }
        }
        expect("${1}${1}${2}${3}${4}") {
            val numbers = byteArrayOf(1, 2, 3, 4)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldIndexed_ShortArray() {
        expect(8) { shortArrayOf(1, 2, 3).foldIndexed(0) { i, acc, e -> acc + i.toShort() * e } }
        expect(10) { shortArrayOf(1, 2, 3).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15) { shortArrayOf(1, 2, 3).foldIndexed(1) { i, acc, e -> acc * (i.toShort() + e) } }
        expect(" 0-${1} 1-${2} 2-${3}") { shortArrayOf(1, 2, 3).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42) {
            val numbers = shortArrayOf(1, 2, 3, 4)
            numbers.foldIndexed(0) { index, a, b -> index.toShort() * (a + b) }
        }
        expect(0) {
            val numbers = shortArrayOf()
            numbers.foldIndexed(0) { index, a, b -> index.toShort() * (a + b) }
        }
        expect("${1}${1}${2}${3}${4}") {
            val numbers = shortArrayOf(1, 2, 3, 4)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldIndexed_IntArray() {
        expect(8) { intArrayOf(1, 2, 3).foldIndexed(0) { i, acc, e -> acc + i.toInt() * e } }
        expect(10) { intArrayOf(1, 2, 3).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15) { intArrayOf(1, 2, 3).foldIndexed(1) { i, acc, e -> acc * (i.toInt() + e) } }
        expect(" 0-${1} 1-${2} 2-${3}") { intArrayOf(1, 2, 3).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42) {
            val numbers = intArrayOf(1, 2, 3, 4)
            numbers.foldIndexed(0) { index, a, b -> index.toInt() * (a + b) }
        }
        expect(0) {
            val numbers = intArrayOf()
            numbers.foldIndexed(0) { index, a, b -> index.toInt() * (a + b) }
        }
        expect("${1}${1}${2}${3}${4}") {
            val numbers = intArrayOf(1, 2, 3, 4)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldIndexed_LongArray() {
        expect(8L) { longArrayOf(1L, 2L, 3L).foldIndexed(0L) { i, acc, e -> acc + i.toLong() * e } }
        expect(10) { longArrayOf(1L, 2L, 3L).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15L) { longArrayOf(1L, 2L, 3L).foldIndexed(1L) { i, acc, e -> acc * (i.toLong() + e) } }
        expect(" 0-${1L} 1-${2L} 2-${3L}") { longArrayOf(1L, 2L, 3L).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42L) {
            val numbers = longArrayOf(1L, 2L, 3L, 4L)
            numbers.foldIndexed(0L) { index, a, b -> index.toLong() * (a + b) }
        }
        expect(0L) {
            val numbers = longArrayOf()
            numbers.foldIndexed(0L) { index, a, b -> index.toLong() * (a + b) }
        }
        expect("${1L}${1L}${2L}${3L}${4L}") {
            val numbers = longArrayOf(1L, 2L, 3L, 4L)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldIndexed_FloatArray() {
        expect(8.0f) { floatArrayOf(1.0f, 2.0f, 3.0f).foldIndexed(0.0f) { i, acc, e -> acc + i.toFloat() * e } }
        expect(10) { floatArrayOf(1.0f, 2.0f, 3.0f).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15.0f) { floatArrayOf(1.0f, 2.0f, 3.0f).foldIndexed(1.0f) { i, acc, e -> acc * (i.toFloat() + e) } }
        expect(" 0-${1.0f} 1-${2.0f} 2-${3.0f}") { floatArrayOf(1.0f, 2.0f, 3.0f).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42.0f) {
            val numbers = floatArrayOf(1.0f, 2.0f, 3.0f, 4.0f)
            numbers.foldIndexed(0.0f) { index, a, b -> index.toFloat() * (a + b) }
        }
        expect(0.0f) {
            val numbers = floatArrayOf()
            numbers.foldIndexed(0.0f) { index, a, b -> index.toFloat() * (a + b) }
        }
        expect("${1.0f}${1.0f}${2.0f}${3.0f}${4.0f}") {
            val numbers = floatArrayOf(1.0f, 2.0f, 3.0f, 4.0f)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldIndexed_DoubleArray() {
        expect(8.0) { doubleArrayOf(1.0, 2.0, 3.0).foldIndexed(0.0) { i, acc, e -> acc + i.toDouble() * e } }
        expect(10) { doubleArrayOf(1.0, 2.0, 3.0).foldIndexed(1) { i, acc, e -> acc + i + e.toInt() } }
        expect(15.0) { doubleArrayOf(1.0, 2.0, 3.0).foldIndexed(1.0) { i, acc, e -> acc * (i.toDouble() + e) } }
        expect(" 0-${1.0} 1-${2.0} 2-${3.0}") { doubleArrayOf(1.0, 2.0, 3.0).foldIndexed("") { i, acc, e -> "$acc $i-$e" } }
        expect(42.0) {
            val numbers = doubleArrayOf(1.0, 2.0, 3.0, 4.0)
            numbers.foldIndexed(0.0) { index, a, b -> index.toDouble() * (a + b) }
        }
        expect(0.0) {
            val numbers = doubleArrayOf()
            numbers.foldIndexed(0.0) { index, a, b -> index.toDouble() * (a + b) }
        }
        expect("${1.0}${1.0}${2.0}${3.0}${4.0}") {
            val numbers = doubleArrayOf(1.0, 2.0, 3.0, 4.0)
            numbers.map { it.toString() }.foldIndexed("") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test
    fun foldRightIndexed_Array() {
        expect(8) { arrayOf<Int>(1, 2, 3).foldRightIndexed(0) { i, e, acc -> acc + i.toInt() * e } }
        expect(10) { arrayOf<Int>(1, 2, 3).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15) { arrayOf<Int>(1, 2, 3).foldRightIndexed(1) { i, e, acc -> acc * (i.toInt() + e) } }
        expect(" 2-${3} 1-${2} 0-${1}") { arrayOf<Int>(1, 2, 3).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1}${2}${3}${4}3210") {
            val numbers = arrayOf<Int>(1, 2, 3, 4)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun foldRightIndexed_ByteArray() {
        expect(8) { byteArrayOf(1, 2, 3).foldRightIndexed(0) { i, e, acc -> acc + i.toByte() * e } }
        expect(10) { byteArrayOf(1, 2, 3).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15) { byteArrayOf(1, 2, 3).foldRightIndexed(1) { i, e, acc -> acc * (i.toByte() + e) } }
        expect(" 2-${3} 1-${2} 0-${1}") { byteArrayOf(1, 2, 3).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1}${2}${3}${4}3210") {
            val numbers = byteArrayOf(1, 2, 3, 4)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun foldRightIndexed_ShortArray() {
        expect(8) { shortArrayOf(1, 2, 3).foldRightIndexed(0) { i, e, acc -> acc + i.toShort() * e } }
        expect(10) { shortArrayOf(1, 2, 3).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15) { shortArrayOf(1, 2, 3).foldRightIndexed(1) { i, e, acc -> acc * (i.toShort() + e) } }
        expect(" 2-${3} 1-${2} 0-${1}") { shortArrayOf(1, 2, 3).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1}${2}${3}${4}3210") {
            val numbers = shortArrayOf(1, 2, 3, 4)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun foldRightIndexed_IntArray() {
        expect(8) { intArrayOf(1, 2, 3).foldRightIndexed(0) { i, e, acc -> acc + i.toInt() * e } }
        expect(10) { intArrayOf(1, 2, 3).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15) { intArrayOf(1, 2, 3).foldRightIndexed(1) { i, e, acc -> acc * (i.toInt() + e) } }
        expect(" 2-${3} 1-${2} 0-${1}") { intArrayOf(1, 2, 3).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1}${2}${3}${4}3210") {
            val numbers = intArrayOf(1, 2, 3, 4)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun foldRightIndexed_LongArray() {
        expect(8L) { longArrayOf(1L, 2L, 3L).foldRightIndexed(0L) { i, e, acc -> acc + i.toLong() * e } }
        expect(10) { longArrayOf(1L, 2L, 3L).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15L) { longArrayOf(1L, 2L, 3L).foldRightIndexed(1L) { i, e, acc -> acc * (i.toLong() + e) } }
        expect(" 2-${3L} 1-${2L} 0-${1L}") { longArrayOf(1L, 2L, 3L).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1L}${2L}${3L}${4L}3210") {
            val numbers = longArrayOf(1L, 2L, 3L, 4L)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun foldRightIndexed_FloatArray() {
        expect(8.0f) { floatArrayOf(1.0f, 2.0f, 3.0f).foldRightIndexed(0.0f) { i, e, acc -> acc + i.toFloat() * e } }
        expect(10) { floatArrayOf(1.0f, 2.0f, 3.0f).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15.0f) { floatArrayOf(1.0f, 2.0f, 3.0f).foldRightIndexed(1.0f) { i, e, acc -> acc * (i.toFloat() + e) } }
        expect(" 2-${3.0f} 1-${2.0f} 0-${1.0f}") { floatArrayOf(1.0f, 2.0f, 3.0f).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1.0f}${2.0f}${3.0f}${4.0f}3210") {
            val numbers = floatArrayOf(1.0f, 2.0f, 3.0f, 4.0f)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun foldRightIndexed_DoubleArray() {
        expect(8.0) { doubleArrayOf(1.0, 2.0, 3.0).foldRightIndexed(0.0) { i, e, acc -> acc + i.toDouble() * e } }
        expect(10) { doubleArrayOf(1.0, 2.0, 3.0).foldRightIndexed(1) { i, e, acc -> acc + i + e.toInt() } }
        expect(15.0) { doubleArrayOf(1.0, 2.0, 3.0).foldRightIndexed(1.0) { i, e, acc -> acc * (i.toDouble() + e) } }
        expect(" 2-${3.0} 1-${2.0} 0-${1.0}") { doubleArrayOf(1.0, 2.0, 3.0).foldRightIndexed("") { i, e, acc -> "$acc $i-$e" } }
        expect("${1.0}${2.0}${3.0}${4.0}3210") {
            val numbers = doubleArrayOf(1.0, 2.0, 3.0, 4.0)
            numbers.map { it.toString() }.foldRightIndexed("") { index, a, b -> a + b + index }
        }
    }

    @Test
    fun minBy_ByteArray() {
        assertEquals(null, byteArrayOf().minBy { it })
        assertEquals(1, byteArrayOf(1).minBy { it })
        assertEquals(2, byteArrayOf(3, 2).minBy { it * it })
        assertEquals(3, byteArrayOf(3, 2).minBy { "a" })
        assertEquals(2, byteArrayOf(3, 2).minBy { it.toString() })
            assertEquals(3, byteArrayOf(2, 3).minBy { -it })
            
    }

    @Test
    fun minBy_ShortArray() {
        assertEquals(null, shortArrayOf().minBy { it })
        assertEquals(1, shortArrayOf(1).minBy { it })
        assertEquals(2, shortArrayOf(3, 2).minBy { it * it })
        assertEquals(3, shortArrayOf(3, 2).minBy { "a" })
        assertEquals(2, shortArrayOf(3, 2).minBy { it.toString() })
            assertEquals(3, shortArrayOf(2, 3).minBy { -it })
            
    }

    @Test
    fun minBy_IntArray() {
        assertEquals(null, intArrayOf().minBy { it })
        assertEquals(1, intArrayOf(1).minBy { it })
        assertEquals(2, intArrayOf(3, 2).minBy { it * it })
        assertEquals(3, intArrayOf(3, 2).minBy { "a" })
        assertEquals(2, intArrayOf(3, 2).minBy { it.toString() })
            assertEquals(3, intArrayOf(2, 3).minBy { -it })
            
    }

    @Test
    fun minBy_LongArray() {
        assertEquals(null, longArrayOf().minBy { it })
        assertEquals(1L, longArrayOf(1L).minBy { it })
        assertEquals(2L, longArrayOf(3L, 2L).minBy { it * it })
        assertEquals(3L, longArrayOf(3L, 2L).minBy { "a" })
        assertEquals(2L, longArrayOf(3L, 2L).minBy { it.toString() })
            assertEquals(3L, longArrayOf(2L, 3L).minBy { -it })
            
        assertEquals(2000000000000, longArrayOf(3000000000000, 2000000000000).minBy { it + 1 })
    }

    @Test
    fun minBy_FloatArray() {
        assertEquals(null, floatArrayOf().minBy { it })
        assertEquals(1.0f, floatArrayOf(1.0f).minBy { it })
        assertEquals(2.0f, floatArrayOf(3.0f, 2.0f).minBy { it * it })
        assertEquals(3.0f, floatArrayOf(3.0f, 2.0f).minBy { "a" })
        assertEquals(2.0f, floatArrayOf(3.0f, 2.0f).minBy { it.toString() })
            assertEquals(3.0f, floatArrayOf(2.0f, 3.0f).minBy { -it })
            
    }

    @Test
    fun minBy_DoubleArray() {
        assertEquals(null, doubleArrayOf().minBy { it })
        assertEquals(1.0, doubleArrayOf(1.0).minBy { it })
        assertEquals(2.0, doubleArrayOf(3.0, 2.0).minBy { it * it })
        assertEquals(3.0, doubleArrayOf(3.0, 2.0).minBy { "a" })
        assertEquals(2.0, doubleArrayOf(3.0, 2.0).minBy { it.toString() })
            assertEquals(3.0, doubleArrayOf(2.0, 3.0).minBy { -it })
            
    }

    @Test
    fun minBy_BooleanArray() {
        assertEquals(true, booleanArrayOf(true, false).maxBy { it.toString() })
        assertEquals(false, booleanArrayOf(true, false).maxBy { it.toString().length })
    }

    @Test
    fun minBy_CharArray() {
        assertEquals('b', charArrayOf('a', 'b').maxBy { "x$it" })
        assertEquals('a', charArrayOf('a', 'b').maxBy { "$it".length })
    }

    @Test
    fun minWith_Array() {
        assertEquals(null, arrayOf<Int>().minWith(naturalOrder()) )
        assertEquals("a", arrayOf("a", "B").minWith(STRING_CASE_INSENSITIVE_ORDER))
    }

    @Test
    fun minWith_ByteArray() {
        assertEquals(null, byteArrayOf().minWith(naturalOrder()))
        assertEquals(1, byteArrayOf(1).minWith(naturalOrder()))
        assertEquals(4, byteArrayOf(2, 3, 4).minWith(compareBy { it % 4 }))
    }

    @Test
    fun minWith_ShortArray() {
        assertEquals(null, shortArrayOf().minWith(naturalOrder()))
        assertEquals(1, shortArrayOf(1).minWith(naturalOrder()))
        assertEquals(4, shortArrayOf(2, 3, 4).minWith(compareBy { it % 4 }))
    }

    @Test
    fun minWith_IntArray() {
        assertEquals(null, intArrayOf().minWith(naturalOrder()))
        assertEquals(1, intArrayOf(1).minWith(naturalOrder()))
        assertEquals(4, intArrayOf(2, 3, 4).minWith(compareBy { it % 4 }))
    }

    @Test
    fun minWith_LongArray() {
        assertEquals(null, longArrayOf().minWith(naturalOrder()))
        assertEquals(1L, longArrayOf(1L).minWith(naturalOrder()))
        assertEquals(4L, longArrayOf(2L, 3L, 4L).minWith(compareBy { it % 4L }))
    }

    @Test
    fun minWith_FloatArray() {
        assertEquals(null, floatArrayOf().minWith(naturalOrder()))
        assertEquals(1.0f, floatArrayOf(1.0f).minWith(naturalOrder()))
        assertEquals(4.0f, floatArrayOf(2.0f, 3.0f, 4.0f).minWith(compareBy { it % 4.0f }))
    }

    @Test
    fun minWith_DoubleArray() {
        assertEquals(null, doubleArrayOf().minWith(naturalOrder()))
        assertEquals(1.0, doubleArrayOf(1.0).minWith(naturalOrder()))
        assertEquals(4.0, doubleArrayOf(2.0, 3.0, 4.0).minWith(compareBy { it % 4.0 }))
    }

    @Test
    fun indexOf_Array() {
        expect(-1) { arrayOf<Int>(1, 2, 3).indexOf(0) }
        expect(0) { arrayOf<Int>(1, 2, 3).indexOf(1) }
        expect(1) { arrayOf<Int>(1, 2, 3).indexOf(2) }
        expect(2) { arrayOf<Int>(1, 2, 3).indexOf(3) } 
        expect(-1) { arrayOf("cat", "dog", "bird").indexOf("mouse") }
        expect(0) { arrayOf("cat", "dog", "bird").indexOf("cat") }
        expect(1) { arrayOf("cat", "dog", "bird").indexOf("dog") }
        expect(2) { arrayOf("cat", "dog", "bird").indexOf("bird") }
        expect(0) { arrayOf(null, "dog", null).indexOf(null as String?)}
    }

    @Test
    fun indexOf_ByteArray() {
        expect(-1) { byteArrayOf(1, 2, 3).indexOf(0) }
        expect(0) { byteArrayOf(1, 2, 3).indexOf(1) }
        expect(1) { byteArrayOf(1, 2, 3).indexOf(2) }
        expect(2) { byteArrayOf(1, 2, 3).indexOf(3) } 
    }

    @Test
    fun indexOf_ShortArray() {
        expect(-1) { shortArrayOf(1, 2, 3).indexOf(0) }
        expect(0) { shortArrayOf(1, 2, 3).indexOf(1) }
        expect(1) { shortArrayOf(1, 2, 3).indexOf(2) }
        expect(2) { shortArrayOf(1, 2, 3).indexOf(3) } 
    }

    @Test
    fun indexOf_IntArray() {
        expect(-1) { intArrayOf(1, 2, 3).indexOf(0) }
        expect(0) { intArrayOf(1, 2, 3).indexOf(1) }
        expect(1) { intArrayOf(1, 2, 3).indexOf(2) }
        expect(2) { intArrayOf(1, 2, 3).indexOf(3) } 
    }

    @Test
    fun indexOf_LongArray() {
        expect(-1) { longArrayOf(1L, 2L, 3L).indexOf(0L) }
        expect(0) { longArrayOf(1L, 2L, 3L).indexOf(1L) }
        expect(1) { longArrayOf(1L, 2L, 3L).indexOf(2L) }
        expect(2) { longArrayOf(1L, 2L, 3L).indexOf(3L) } 
    }

    @Test
    fun indexOf_FloatArray() {
        expect(-1) { floatArrayOf(1.0f, 2.0f, 3.0f).indexOf(0.0f) }
        expect(0) { floatArrayOf(1.0f, 2.0f, 3.0f).indexOf(1.0f) }
        expect(1) { floatArrayOf(1.0f, 2.0f, 3.0f).indexOf(2.0f) }
        expect(2) { floatArrayOf(1.0f, 2.0f, 3.0f).indexOf(3.0f) } 
    }

    @Test
    fun indexOf_DoubleArray() {
        expect(-1) { doubleArrayOf(1.0, 2.0, 3.0).indexOf(0.0) }
        expect(0) { doubleArrayOf(1.0, 2.0, 3.0).indexOf(1.0) }
        expect(1) { doubleArrayOf(1.0, 2.0, 3.0).indexOf(2.0) }
        expect(2) { doubleArrayOf(1.0, 2.0, 3.0).indexOf(3.0) } 
    }

    @Test
    fun indexOf_BooleanArray() {
        expect(0) { booleanArrayOf(true, false).indexOf(true) }
        expect(1) { booleanArrayOf(true, false).indexOf(false) }
        expect(-1) { booleanArrayOf(true).indexOf(false) } 
    }

    @Test
    fun indexOf_CharArray() {
        expect(-1) { charArrayOf('a', 'b', 'c').indexOf('z') }
        expect(0) { charArrayOf('a', 'b', 'c').indexOf('a') }
        expect(1) { charArrayOf('a', 'b', 'c').indexOf('b') }
        expect(2) { charArrayOf('a', 'b', 'c').indexOf('c') } 
    }

    @Test
    fun indexOfFirst_Array() {
        expect(-1) { arrayOf<Int>(1, 2, 3).indexOfFirst { it == 0 } }
        expect(0) { arrayOf<Int>(1, 2, 3).indexOfFirst { it % 2 == 1 } }
        expect(1) { arrayOf<Int>(1, 2, 3).indexOfFirst { it % 2 == 0 } }
        expect(2) { arrayOf<Int>(1, 2, 3).indexOfFirst { it == 3 } }
        expect(-1) { arrayOf("cat", "dog", "bird").indexOfFirst { it.contains("p") } }
        expect(0) { arrayOf("cat", "dog", "bird").indexOfFirst { it.startsWith('c') } }
        expect(1) { arrayOf("cat", "dog", "bird").indexOfFirst { it.startsWith('d') } }
        expect(2) { arrayOf("cat", "dog", "bird").indexOfFirst { it.endsWith('d') } }
    }

    @Test
    fun indexOfFirst_ByteArray() {
        expect(-1) { byteArrayOf(1, 2, 3).indexOfFirst { it == 0.toByte() } }
        expect(0) { byteArrayOf(1, 2, 3).indexOfFirst { it % 2 == 1 } }
        expect(1) { byteArrayOf(1, 2, 3).indexOfFirst { it % 2 == 0 } }
        expect(2) { byteArrayOf(1, 2, 3).indexOfFirst { it == 3.toByte() } }
    }

    @Test
    fun indexOfFirst_ShortArray() {
        expect(-1) { shortArrayOf(1, 2, 3).indexOfFirst { it == 0.toShort() } }
        expect(0) { shortArrayOf(1, 2, 3).indexOfFirst { it % 2 == 1 } }
        expect(1) { shortArrayOf(1, 2, 3).indexOfFirst { it % 2 == 0 } }
        expect(2) { shortArrayOf(1, 2, 3).indexOfFirst { it == 3.toShort() } }
    }

    @Test
    fun indexOfFirst_IntArray() {
        expect(-1) { intArrayOf(1, 2, 3).indexOfFirst { it == 0 } }
        expect(0) { intArrayOf(1, 2, 3).indexOfFirst { it % 2 == 1 } }
        expect(1) { intArrayOf(1, 2, 3).indexOfFirst { it % 2 == 0 } }
        expect(2) { intArrayOf(1, 2, 3).indexOfFirst { it == 3 } }
    }

    @Test
    fun indexOfFirst_LongArray() {
        expect(-1) { longArrayOf(1L, 2L, 3L).indexOfFirst { it == 0L } }
        expect(0) { longArrayOf(1L, 2L, 3L).indexOfFirst { it % 2L == 1L } }
        expect(1) { longArrayOf(1L, 2L, 3L).indexOfFirst { it % 2L == 0L } }
        expect(2) { longArrayOf(1L, 2L, 3L).indexOfFirst { it == 3L } }
    }

    @Test
    fun indexOfFirst_FloatArray() {
        expect(-1) { floatArrayOf(1.0f, 2.0f, 3.0f).indexOfFirst { it == 0.0f } }
        expect(0) { floatArrayOf(1.0f, 2.0f, 3.0f).indexOfFirst { it % 2.0f == 1.0f } }
        expect(1) { floatArrayOf(1.0f, 2.0f, 3.0f).indexOfFirst { it % 2.0f == 0.0f } }
        expect(2) { floatArrayOf(1.0f, 2.0f, 3.0f).indexOfFirst { it == 3.0f } }
    }

    @Test
    fun indexOfFirst_DoubleArray() {
        expect(-1) { doubleArrayOf(1.0, 2.0, 3.0).indexOfFirst { it == 0.0 } }
        expect(0) { doubleArrayOf(1.0, 2.0, 3.0).indexOfFirst { it % 2.0 == 1.0 } }
        expect(1) { doubleArrayOf(1.0, 2.0, 3.0).indexOfFirst { it % 2.0 == 0.0 } }
        expect(2) { doubleArrayOf(1.0, 2.0, 3.0).indexOfFirst { it == 3.0 } }
    }

    @Test
    fun indexOfFirst_BooleanArray() {
        expect(0) { booleanArrayOf(true, false, false, true).indexOfFirst { it } }
        expect(1) { booleanArrayOf(true, false, false, true).indexOfFirst { !it } }
        expect(-1) { booleanArrayOf(true, true).indexOfFirst { !it } } 
    }

    @Test
    fun indexOfFirst_CharArray() {
        expect(-1) { charArrayOf('a', 'b', 'c').indexOfFirst { it == 'z' } }
        expect(0) { charArrayOf('a', 'b', 'c').indexOfFirst { it < 'c' } }
        expect(1) { charArrayOf('a', 'b', 'c').indexOfFirst { it > 'a' } }
        expect(2) { charArrayOf('a', 'b', 'c').indexOfFirst { it != 'a' && it != 'b' } } 
    }

    @Test
    fun copyInto_ByteArray() {
        val dest = byteArrayOf(1, 2, 3)
        val newValues = byteArrayOf(4, 5, 6)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = byteArrayOf(5, 6, 3)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = byteArrayOf(6, 3, 3)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = byteArrayOf(6, 6, 3)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

    @Test
    fun copyInto_ShortArray() {
        val dest = shortArrayOf(1, 2, 3)
        val newValues = shortArrayOf(4, 5, 6)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = shortArrayOf(5, 6, 3)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = shortArrayOf(6, 3, 3)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = shortArrayOf(6, 6, 3)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

    @Test
    fun copyInto_IntArray() {
        val dest = intArrayOf(1, 2, 3)
        val newValues = intArrayOf(4, 5, 6)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = intArrayOf(5, 6, 3)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = intArrayOf(6, 3, 3)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = intArrayOf(6, 6, 3)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

    @Test
    fun copyInto_LongArray() {
        val dest = longArrayOf(1L, 2L, 3L)
        val newValues = longArrayOf(4L, 5L, 6L)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = longArrayOf(5L, 6L, 3L)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = longArrayOf(6L, 3L, 3L)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = longArrayOf(6L, 6L, 3L)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

    @Test
    fun copyInto_FloatArray() {
        val dest = floatArrayOf(1.0f, 2.0f, 3.0f)
        val newValues = floatArrayOf(4.0f, 5.0f, 6.0f)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = floatArrayOf(5.0f, 6.0f, 3.0f)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = floatArrayOf(6.0f, 3.0f, 3.0f)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = floatArrayOf(6.0f, 6.0f, 3.0f)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

    @Test
    fun copyInto_DoubleArray() {
        val dest = doubleArrayOf(1.0, 2.0, 3.0)
        val newValues = doubleArrayOf(4.0, 5.0, 6.0)
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = doubleArrayOf(5.0, 6.0, 3.0)
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = doubleArrayOf(6.0, 3.0, 3.0)
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = doubleArrayOf(6.0, 6.0, 3.0)
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

    @Test
    fun copyInto_CharArray() {
        val dest = arrayOf('a', 'b', 'c')
        val newValues = arrayOf('e', 'f', 'g')
        newValues.copyInto(dest, 0, 1, 3)
        val result1 = arrayOf('f', 'g', 'c')
        assertTrue(result1 contentEquals dest, "Copying from newValues: ${result1.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 0, 1, 3)
        val result2 = arrayOf('g', 'c', 'c')
        assertTrue(result2 contentEquals dest, "Overlapping backward copy: ${result2.contentToString()}, ${dest.contentToString()}")
        dest.copyInto(dest, 1, 0, 2)
        val result3 = arrayOf('g', 'g', 'c')
        assertTrue(result3 contentEquals dest, "Overlapping forward copy: ${result2.contentToString()}, ${dest.contentToString()}") 
        for ((start, end) in listOf(-1 to 0, 0 to 4, 4 to 4, 1 to 0, 0 to -1)) {
            val bounds = "start: $start, end: $end"
            val ex = assertFails(bounds) { newValues.copyInto(dest, 0, start, end) }
            assertTrue(ex is IllegalArgumentException || ex is IndexOutOfBoundsException, "Unexpected exception type: $ex")
        }
        for (destIndex in listOf(-1, 2, 4)) {
            assertFailsWith<IndexOutOfBoundsException>("index: $destIndex") { newValues.copyInto(dest, destIndex, 0, 2) }
        } 
    }

}
